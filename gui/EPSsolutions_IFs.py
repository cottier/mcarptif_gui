# Generate starting solutions using the extended path scanning heuristic
# Elias Willemse, CSIR Pretoria, Created 10 October 2009. 
#
# Derived from the article:
# Belenguer, J., Benavent, E., Lacomme, P., Prins, C. (2006). Lower and uper 
# bounds for the mixed capacitated arc routing problem. Computers and Operations
# Research. 33(12) 
# p. 3363-3383.
# Specifically pages 3369-3370.

import LancommeARPconversions3 as LARP
import dictFind
import random
import testSolutions
import UlusoyHeuristics
import copy
import reduceNumberTrips_IF
import transformSolution
from copy import deepcopy

#===============================================================================
# Uses info generated by LARP class to generate an initial solution assuming one
# depot and no intermediate facilities. Starts from depot and assigns the 
# closest required arc to a vehicle route, untill capacity is reached. The 
# vehilce then returns to the depot. Tie breaking rules are used if more than
# one edge is the closest to a current edge.
#===============================================================================
class EPSinitialSolution(object):
    
    def __init__(self, info):
        '''
        Returns an EPS initial solution
        '''
        self.info = info
        self.EPSsolution = {}
        self.bestIF = self.info.bestIFD
        self.bestIFdistD = self.info.bestIFdistD
        self.printOutput = True
        self.outputLines = []
        self.minN = reduceNumberTrips_IF.ReduceNumberOfVehicleRoutes(self.info)
        self.trans = transformSolution.transformSolution(self.info)
        
    def maxDepoRule(self, nearest, Load):
        '''
        break tie by assigning arc that is the furthest from the depot, once 
        serviced
        '''
        DistanceDepo = -1
        depotUse = self.info.depotArc
        chooseNearest = None
        VehicleFull = False
        chooseNearestNoCap = None
        DistanceDepoNoCap = -1
        for i in nearest:
            if (self.info.spDistanceD[i][depotUse] > DistanceDepo) & (self.info.demandD[i] + Load < self.info.capacity):
                chooseNearest = i
                DistanceDepo = self.info.spDistanceD[i][depotUse]
            elif (self.info.spDistanceD[i][depotUse] > DistanceDepoNoCap):
                chooseNearestNoCap = i
                DistanceDepoNoCap = self.info.spDistanceD[i][depotUse]
        if DistanceDepo == -1: 
            VehicleFull = True 
            chooseNearest = chooseNearestNoCap
            
        return(VehicleFull, chooseNearest)

        
    def minDepoRule(self, nearest, Load):
        '''
        break tie by assigning arc that is the closest to the depot once 
        serviced
        '''
        huge = 1e30000
        DistanceDepo = huge
        chooseNearest = None    
        VehicleFull = False
        depot = self.info.depotArc
        vehicleCap = self.info.capacity
        chooseNearestNoCap = None
        DistanceDepoNoCap = huge
    
        for i in nearest:
            if (self.info.spDistanceD[i][depot] < DistanceDepo) & (self.info.demandD[i] + Load < vehicleCap):
                chooseNearest = i
                DistanceDepo = self.info.spDistanceD[i][depot]
            elif (self.info.spDistanceD[i][depot] < DistanceDepoNoCap):
                chooseNearestNoCap = i
                DistanceDepoNoCap = self.info.spDistanceD[i][depot]
        if DistanceDepo == huge: 
            VehicleFull = True
            chooseNearest = chooseNearestNoCap
        return(VehicleFull, chooseNearest)
            
        
    def maxYieldRule(self, nearest, Load):
        '''
        Break tie by assigning some sort of efficiency rule. Efficiency is the 
        the demand of the arc devided by its service time.
        '''
        Yield = 0.0
        chooseNearest = None
        VehicleFull = False
        vehicleCap = self.info.capacity
        chooseNearestNoCap = None
            
        for i in nearest:
            if (float(self.info.demandD[i]) / self.info.serveCostD[i] > Yield) & (self.info.demandD[i] + Load < vehicleCap):
                chooseNearest = i
                Yield = float(self.info.demandD[i]) / self.info.serveCostD[i]
            elif (float(self.info.demandD[i]) / self.info.serveCostD[i] > Yield):
                chooseNearestNoCap = i        
        if Yield == 0.0: 
            chooseNearest = chooseNearestNoCap
            VehicleFull = True
        
        return(VehicleFull, chooseNearest)
        
    def minYieldRule(self, nearest, Load):
        '''
        Oposite of max yield rule
        '''
        huge = 1e30000
        Yield = huge
        chooseNearest = None
        VehicleFull = False
        vehicleCap = self.info.capacity
        chooseNearestNoCap = None
        
        for i in nearest:
            if (float(self.info.demandD[i]) / self.info.serveCostD[i] < Yield) & (self.info.demandD[i] + Load < vehicleCap):
                chooseNearest = i
                Yield = float(self.info.demandD[i]) / self.info.serveCostD[i]
            elif (float(self.info.demandD[i]) / self.info.serveCostD[i] < Yield):
                chooseNearestNoCap = i
        if Yield == huge:
            chooseNearest = chooseNearestNoCap
            VehicleFull = True
        
        return(VehicleFull, chooseNearest)
         
    def noRule(self, nearest, Load):
        '''
        Randomly choose what edge can be added.
        '''
        vehicleCap = self.info.capacity
        chooseNearest = None
        VehicleFull = False
        chooseNearestNoCap = nearest[random.randint(0, len(nearest) - 1)]
        while chooseNearest == None:
            i = random.randint(0, len(nearest) - 1)
            if (self.info.demandD[nearest[i]] + Load) < vehicleCap:
                chooseNearest = nearest[i]
            else:
                nearest.remove(nearest[i])
            if len(nearest) == 0:
                VehicleFull = True
                chooseNearest = chooseNearestNoCap
                break
        return(VehicleFull, chooseNearest)
    
    def breakTie(self, rule, nearest, Halfull, Load):
        '''
        Use one of the rules to break ties. Another option is hybrid and random-
        rule.
        '''
        rules = ['MaxDepo', 'MinDepo', 'MaxYield', 'MinYield', 'Hybrid']
        
        if rule == 'RandomRule':
            rule = rules[random.randint(0, len(rules) - 1)]
    
        if rule == 'MaxDepo':
            (VehicleFull, chooseNearest) = self.maxDepoRule(nearest, Load)
        elif rule == 'MinDepo':
            (VehicleFull, chooseNearest) = self.minDepoRule(nearest, Load)
        elif rule == 'MaxYield':
            (VehicleFull, chooseNearest) = self.maxYieldRule(nearest, Load)
        elif rule == 'MinYield':
            (VehicleFull, chooseNearest) = self.minYieldRule(nearest, Load)
        elif rule == 'Hybrid':
            if Halfull:
                (VehicleFull, chooseNearest) = self.minDepoRule(nearest, Load)
            else:
                (VehicleFull, chooseNearest) = self.maxDepoRule(nearest, Load)
        elif rule == 'NoRule':
            (VehicleFull, chooseNearest) = self.noRule(nearest, Load)
        
        return(VehicleFull, chooseNearest)
         
    def singleRoute(self, rule, collectFlag):
        '''
        Generate single route untill vehicle capacity is reached. Capacity is 
        reached when the demand of the closest arcs exceeds the vehicles 
        available capacity. Improvement would be to then look at second closest
        vertex. It is actual rather simple. Generate a list of arcs not yet 
        seriviced whos demand can be met. And choose the closest of those
        edges. Might want to include a rule preventing edges to far away to be 
        added. Radius or elpise rule? Improve perfomance by calculating 
        remaining capacity and only looking at possible edges. 
        '''
        depot = self.info.depotArc
        vehicleCapacity = self.info.capacity
        dumpCost = self.info.dumpCost
        
        Halfull = False
        VehicleFull = False
        Sequence = [depot]
        
        Cost = 0
        Load = 0
        
        while VehicleFull == False:
            
            collectedFind = dictFind.Lookup(collectFlag)
            Unserviced = collectedFind.get_key(False)
            
            if Unserviced == []:break
            
            nearest = []
            NearestDist = 1e30000
            LastEdge = Sequence[ - 1]
            
            for i in Unserviced:
                distanceNextEdge = self.info.spDistanceD[LastEdge][i]
                if distanceNextEdge < NearestDist:
                    nearest = []
                    NearestDist = distanceNextEdge
                    nearest.append(i)
                elif distanceNextEdge == NearestDist: nearest.append(i)
        
            if len(nearest) > 1:

                (VehicleFull, chooseNearest) = self.breakTie(rule, nearest, Halfull, Load)

            elif len(nearest) == 1:
                chooseNearest = nearest[0]
            else: break
            
            if VehicleFull: break
            elif (Load + self.info.demandD[chooseNearest]) > vehicleCapacity: break
        
            Cost = Cost + self.info.spDistanceD[LastEdge][chooseNearest] + self.info.serveCostD[chooseNearest]
            Load = Load + self.info.demandD[chooseNearest]
            if Load > vehicleCapacity / 2.0: Halfull = True
            Sequence.append(chooseNearest)
            collectFlag[chooseNearest] = True
            if self.info.invArcD[chooseNearest]:collectFlag[self.info.invArcD[chooseNearest]] = True
        
        Cost = Cost + self.info.spDistanceD[Sequence[ - 1]][depot] + dumpCost     
        Sequence.append(depot)
        
        return(Cost, Load, Sequence, collectFlag)   
            
    def singleRouteIF(self, rule, collectFlag):
        '''
        Generate single route untill vehicle capacity is reached. Capacity is 
        reached when the demand of the closest arcs exceeds the vehicles 
        available capacity. Improvement would be to then look at second closest
        vertex. It is actual rather simple. Generate a list of arcs not yet 
        seriviced whos demand can be met. And choose the closest of those
        edges. Might want to include a rule preventing edges to far away to be 
        added. Radius or elpise rule? Improve perfomance by calculating 
        remaining capacity and only looking at possible edges. 
        '''
        depot = self.info.depotArc
        vehicleCapacity = self.info.capacity
        vehicleMaxTrip = self.info.maxTrip
        dumpCost = self.info.dumpCost
        
        TripFull = False
        sequenceWithIFs = []
        ifLoad = []
        Cost = 0
        
        nTrips = -1
        while TripFull == False:
            Load = 0
            Halfull = False
            VehicleFull = False
            collectedFind = dictFind.Lookup(collectFlag)
            Unserviced = collectedFind.get_key(False)
            Sequence = []
            if Unserviced == []:break
            nTrips += 1
            if nTrips == 0:Sequence = [depot]
            else:Sequence.append(sequenceWithIFs[nTrips-1][-1])
            
            while VehicleFull == False:
                
                collectedFind = dictFind.Lookup(collectFlag)
                Unserviced = collectedFind.get_key(False)
                
                if Unserviced == []:break
                
                nearest = []
                NearestDist = 1e30000
                LastEdge = Sequence[ - 1]
                VehicleFull = True
                TripFull = True
                for i in Unserviced:
                    distanceNextEdge = self.info.spDistanceD[LastEdge][i]
                    dummyCost = Cost + self.info.spDistanceD[LastEdge][i] + self.info.serveCostD[i] + dumpCost + self.bestIFdistD[i][depot] 
                    dummyLoad = Load + self.info.demandD[i]
                    if dummyCost <= vehicleMaxTrip:
                        TripFull = False
                        if dummyLoad <= vehicleCapacity:
                            VehicleFull = False
                            if (distanceNextEdge < NearestDist):
                                nearest = []
                                NearestDist = distanceNextEdge
                                nearest.append(i)
                            elif (distanceNextEdge == NearestDist):
                                nearest.append(i)

                if TripFull:break
                if len(nearest) > 1:
                    (VehicleFull, chooseNearest) = self.breakTie(rule, nearest, Halfull, Load)
                elif len(nearest) == 1:chooseNearest = nearest[0]
                                                
                if VehicleFull:
                    bestOpt = 1e30000
                    for i in Unserviced:
                        c = self.bestIFdistD[Sequence[-1]][i]
                        if c < bestOpt:
                            bestPlaced = i
                            bestOpt = c
                    bstIF = self.bestIF[Sequence[-1]][bestPlaced]
                    Cost = Cost + self.info.spDistanceD[Sequence[-1]][bstIF] + dumpCost
                    Sequence.append(bstIF)
                    break
            
                Cost = Cost + self.info.spDistanceD[LastEdge][chooseNearest] + self.info.serveCostD[chooseNearest]
                Load = Load + self.info.demandD[chooseNearest]
                if Load > vehicleCapacity / 2.0: Halfull = True
                Sequence.append(chooseNearest)
                collectFlag[chooseNearest] = True
                if self.info.invArcD[chooseNearest]:collectFlag[self.info.invArcD[chooseNearest]] = True
            sequenceWithIFs.append(Sequence[:])
            ifLoad.append(copy.deepcopy(Load))
            if Unserviced == []:break
            if TripFull:break

        if len(sequenceWithIFs[-1]) > 1:
            bstIF = self.bestIF[sequenceWithIFs[-1][-1]][depot]
            bstIFcost = self.bestIFdistD[sequenceWithIFs[-1][-1]][depot]
            Cost = Cost +  bstIFcost + dumpCost  
            sequenceWithIFs[-1].append(bstIF)
            sequenceWithIFs[-1].append(depot)
        else:
            del sequenceWithIFs[-1]
            Cost = Cost + self.info.spDistanceD[sequenceWithIFs[-1][-1]][depot]
            sequenceWithIFs[-1].append(depot)
        return(Cost, ifLoad, sequenceWithIFs, collectFlag)

    def singleRouteIFbalanced(self, rule, collectFlag):
        '''
        Generate single route untill vehicle capacity is reached. Capacity is 
        reached when the demand of the closest arcs exceeds the vehicles 
        available capacity. Improvement would be to then look at second closest
        vertex. It is actual rather simple. Generate a list of arcs not yet 
        seriviced whos demand can be met. And choose the closest of those
        edges. Might want to include a rule preventing edges to far away to be 
        added. Radius or elpise rule? Improve perfomance by calculating 
        remaining capacity and only looking at possible edges. 
        '''
        depot = self.info.depotArc
        vehicleCapacity = self.info.capacity
        vehicleMaxTrip = self.info.maxTrip
        dumpCost = self.info.dumpCost
        
        TripFull = False
        sequenceWithIFs = []
        ifLoad = []
        Cost = 0
        
        nTrips = -1
        
        while TripFull == False:
            Load = 0
            Halfull = False
            VehicleFull = False
            collectedFind = dictFind.Lookup(collectFlag)
            Unserviced = collectedFind.get_key(False)
            Sequence = []
            if Unserviced == []:break
            nTrips += 1
            if nTrips == 0:Sequence = [depot]
            else:Sequence.append(sequenceWithIFs[nTrips-1][-1])
            
            while VehicleFull == False:
                
                collectedFind = dictFind.Lookup(collectFlag)
                Unserviced = collectedFind.get_key(False)
                
                if Unserviced == []:break
                
                nearest = []
                NearestDist = 1e30000
                LastEdge = Sequence[ - 1]
                
                for i in Unserviced:
                    distanceNextEdge = self.info.spDistanceD[LastEdge][i]
                    if distanceNextEdge < NearestDist:
                        nearest = []
                        NearestDist = distanceNextEdge
                        nearest.append(i)
                    elif distanceNextEdge == NearestDist: nearest.append(i)
                  
                if len(nearest) > 1:
                    (VehicleFull, chooseNearest) = self.breakTie(rule, nearest, Halfull, Load)
                elif len(nearest) == 1:
                    chooseNearest = nearest[0]
                else: break
                                
                if (Load + self.info.demandD[chooseNearest]) > vehicleCapacity: 
                    VehicleFull = True
                if VehicleFull:
                    bestOpt = 1e30000
                    for i in Unserviced:
                        c = self.bestIFdistD[Sequence[-1]][i]
                        if c < bestOpt:
                            bestPlaced = i
                            bestOpt = c
                    bstIF = self.bestIF[Sequence[-1]][bestPlaced]
                    Cost = Cost + self.info.spDistanceD[Sequence[-1]][bstIF] + dumpCost
                    Sequence.append(bstIF)
                    break
            
                Cost = Cost + self.info.spDistanceD[LastEdge][chooseNearest] + self.info.serveCostD[chooseNearest]
                dummyCost = Cost + dumpCost + self.bestIFdistD[chooseNearest][depot]
                if dummyCost > vehicleMaxTrip:
                    TripFull = True
                    Cost = Cost - self.info.spDistanceD[LastEdge][chooseNearest] - self.info.serveCostD[chooseNearest]
                    break
                
                Load = Load + self.info.demandD[chooseNearest]
                if Load > vehicleCapacity / 2.0: Halfull = True
                Sequence.append(chooseNearest)
                collectFlag[chooseNearest] = True
                if self.info.invArcD[chooseNearest]:collectFlag[self.info.invArcD[chooseNearest]] = True
                
            sequenceWithIFs.append(Sequence[:])
            ifLoad.append(copy.deepcopy(Load))
            if Unserviced == []:break
            if TripFull:break
            
        if len(sequenceWithIFs[-1]) > 1:
            bstIF = self.bestIF[sequenceWithIFs[-1][-1]][depot]
            bstIFcost = self.bestIFdistD[sequenceWithIFs[-1][-1]][depot]
            Cost = Cost +  bstIFcost + dumpCost  
            sequenceWithIFs[-1].append(bstIF)
            sequenceWithIFs[-1].append(depot)
        else:
            del sequenceWithIFs[-1]
            Cost = Cost + self.info.spDistanceD[sequenceWithIFs[-1][-1]][depot]
            sequenceWithIFs[-1].append(depot)
        return(Cost, ifLoad, sequenceWithIFs, collectFlag)
    
    def singleRouteIFulosoyHybrid(self, rule, collectFlag):
        '''
        Generate single route untill vehicle capacity is reached. Capacity is 
        reached when the demand of the closest arcs exceeds the vehicles 
        available capacity. Improvement would be to then look at second closest
        vertex. It is actual rather simple. Generate a list of arcs not yet 
        seriviced whos demand can be met. And choose the closest of those
        edges. Might want to include a rule preventing edges to far away to be 
        added. Radius or elpise rule? Improve perfomance by calculating 
        remaining capacity and only looking at possible edges. 
        '''
        depot = self.info.depotArc
        vehicleCapacity = self.info.capacity
        vehicleMaxTrip = self.info.maxTrip
        dumpCost = self.info.dumpCost
        
        TripFull = False
        sequenceWithIFs = []
        ifLoad = []
        Cost = 0
        
        nTrips = -1
        
        while TripFull == False:
            Load = 0
            Halfull = False
            VehicleFull = False
            collectedFind = dictFind.Lookup(collectFlag)
            Unserviced = collectedFind.get_key(False)
            Sequence = []
            if Unserviced == []:break
            nTrips += 1
            if nTrips == 0:Sequence = [depot]
            else:Sequence.append(sequenceWithIFs[nTrips-1][-1])
            
            while VehicleFull == False:
                
                collectedFind = dictFind.Lookup(collectFlag)
                Unserviced = collectedFind.get_key(False)
                
                if Unserviced == []:break
                
                nearest = []
                NearestDist = 1e30000
                LastEdge = Sequence[ - 1]
                VehicleFull = True
                TripFull = True
                for i in Unserviced:
                    distanceNextEdge = self.info.spDistanceD[LastEdge][i]
                    dummyCost = Cost + self.info.spDistanceD[LastEdge][i] + self.info.serveCostD[i] + dumpCost + self.bestIFdistD[i][depot] 
                    dummyLoad = Load + self.info.demandD[i]
                    if dummyCost <= vehicleMaxTrip:
                        TripFull = False
                        if dummyLoad <= vehicleCapacity:
                            VehicleFull = False
                            if (distanceNextEdge < NearestDist):
                                nearest = []
                                NearestDist = distanceNextEdge
                                nearest.append(i)
                            elif (distanceNextEdge == NearestDist):
                                nearest.append(i)
    
                if TripFull:break
                
                if len(nearest) > 1:
                    (VehicleFull, chooseNearest) = self.breakTie(rule, nearest, Halfull, Load)
                elif len(nearest) == 1:chooseNearest = nearest[0]
                                                
                if VehicleFull:
                    bestOpt = 1e30000
                    for i in Unserviced:
                        c = self.bestIFdistD[Sequence[-1]][i]
                        if c < bestOpt:
                            bestPlaced = i
                            bestOpt = c
                    bstIF = self.bestIF[Sequence[-1]][bestPlaced]
                    Cost = Cost + self.info.spDistanceD[Sequence[-1]][bstIF] + dumpCost
                    Sequence.append(bstIF)
                    break
            
                Cost = Cost + self.info.spDistanceD[LastEdge][chooseNearest] + self.info.serveCostD[chooseNearest]
                dummyCost = Cost + dumpCost + self.bestIFdistD[chooseNearest][depot]
                if dummyCost > vehicleMaxTrip:
                    TripFull = True
                    Cost = Cost - self.info.spDistanceD[LastEdge][chooseNearest] - self.info.serveCostD[chooseNearest]
                    break
                
                Load = Load + self.info.demandD[chooseNearest]
                if Load > vehicleCapacity / 2.0: Halfull = True
                Sequence.append(chooseNearest)
                collectFlag[chooseNearest] = True
                if self.info.invArcD[chooseNearest]:collectFlag[self.info.invArcD[chooseNearest]] = True
                
            sequenceWithIFs.append(Sequence[:])
            ifLoad.append(copy.deepcopy(Load))
            if Unserviced == []:break
            if TripFull:break

        if len(sequenceWithIFs[-1]) > 1:
            bstIF = self.bestIF[sequenceWithIFs[-1][-1]][depot]
            bstIFcost = self.bestIFdistD[sequenceWithIFs[-1][-1]][depot]
            Cost = Cost +  bstIFcost + dumpCost  
            sequenceWithIFs[-1].append(bstIF)
            sequenceWithIFs[-1].append(depot)
        else:
            del sequenceWithIFs[-1]
            Cost = Cost + self.info.spDistanceD[sequenceWithIFs[-1][-1]][depot]
            sequenceWithIFs[-1].append(depot)

        onlyArcs = []
        i = 0
        for seq in sequenceWithIFs:
            i += 1
            if i == len(sequenceWithIFs):onlyArcs = onlyArcs + seq[1:-2] 
            else:onlyArcs = onlyArcs + seq[1:-1]
        genUlusoyRoutes = UlusoyHeuristics.UlusoysIFs_1vehicle(self.info)         
        (sequenceWithIFs, ifLoad, Cost) = genUlusoyRoutes.genSolutionList(onlyArcs)
        return(Cost, ifLoad, sequenceWithIFs, collectFlag)

    def singleRouteIFulosoyHybridBalanced(self, rule, collectFlag):
        '''
        Generate single route untill vehicle capacity is reached. Capacity is 
        reached when the demand of the closest arcs exceeds the vehicles 
        available capacity. Improvement would be to then look at second closest
        vertex. It is actual rather simple. Generate a list of arcs not yet 
        seriviced whos demand can be met. And choose the closest of those
        edges. Might want to include a rule preventing edges to far away to be 
        added. Radius or elpise rule? Improve perfomance by calculating 
        remaining capacity and only looking at possible edges. 
        '''
        depot = self.info.depotArc
        vehicleCapacity = self.info.capacity
        vehicleMaxTrip = self.info.maxTrip
        dumpCost = self.info.dumpCost
        
        TripFull = False
        sequenceWithIFs = []
        ifLoad = []
        Cost = 0
        
        nTrips = -1
        
        while TripFull == False:
            Load = 0
            Halfull = False
            VehicleFull = False
            collectedFind = dictFind.Lookup(collectFlag)
            Unserviced = collectedFind.get_key(False)
            Sequence = []
            if Unserviced == []:break
            nTrips += 1
            if nTrips == 0:Sequence = [depot]
            else:Sequence.append(sequenceWithIFs[nTrips-1][-1])
            
            while VehicleFull == False:
                
                collectedFind = dictFind.Lookup(collectFlag)
                Unserviced = collectedFind.get_key(False)
                
                if Unserviced == []:break
                
                nearest = []
                NearestDist = 1e30000
                LastEdge = Sequence[ - 1]
                
                for i in Unserviced:
                    distanceNextEdge = self.info.spDistanceD[LastEdge][i]
                    if distanceNextEdge < NearestDist:
                        nearest = []
                        NearestDist = distanceNextEdge
                        nearest.append(i)
                    elif distanceNextEdge == NearestDist: nearest.append(i)
            
                if len(nearest) > 1:
                    (VehicleFull, chooseNearest) = self.breakTie(rule, nearest, Halfull, Load)
                elif len(nearest) == 1:
                    chooseNearest = nearest[0]
                else: break
                                                
                if (Load + self.info.demandD[chooseNearest]) > vehicleCapacity: 
                    VehicleFull = True
                if VehicleFull:
                    bestOpt = 1e30000
                    for i in Unserviced:
                        c = self.bestIFdistD[Sequence[-1]][i]
                        if c < bestOpt:
                            bestPlaced = i
                            bestOpt = c
                    bstIF = self.bestIF[Sequence[-1]][bestPlaced]
                    Cost = Cost + self.info.spDistanceD[Sequence[-1]][bstIF] + dumpCost
                    Sequence.append(bstIF)
                    break
            
                Cost = Cost + self.info.spDistanceD[LastEdge][chooseNearest] + self.info.serveCostD[chooseNearest]
                dummyCost = Cost + dumpCost + self.bestIFdistD[chooseNearest][depot]
                if dummyCost > vehicleMaxTrip:
                    TripFull = True
                    Cost = Cost - self.info.spDistanceD[LastEdge][chooseNearest] - self.info.serveCostD[chooseNearest]
                    break
                
                Load = Load + self.info.demandD[chooseNearest]
                if Load > vehicleCapacity / 2.0: Halfull = True
                Sequence.append(chooseNearest)
                collectFlag[chooseNearest] = True
                if self.info.invArcD[chooseNearest]:collectFlag[self.info.invArcD[chooseNearest]] = True
                
            sequenceWithIFs.append(Sequence[:])
            ifLoad.append(copy.deepcopy(Load))
            if Unserviced == []:break
            if TripFull:break

        if len(sequenceWithIFs[-1]) > 1:
            bstIF = self.bestIF[sequenceWithIFs[-1][-1]][depot]
            bstIFcost = self.bestIFdistD[sequenceWithIFs[-1][-1]][depot]
            Cost = Cost +  bstIFcost + dumpCost  
            sequenceWithIFs[-1].append(bstIF)
            sequenceWithIFs[-1].append(depot)
        else:
            del sequenceWithIFs[-1]
            Cost = Cost + self.info.spDistanceD[sequenceWithIFs[-1][-1]][depot]
            sequenceWithIFs[-1].append(depot)

        onlyArcs = []
        i = 0
        for seq in sequenceWithIFs:
            i += 1
            if i == len(sequenceWithIFs):onlyArcs = onlyArcs + seq[1:-2] 
            else:onlyArcs = onlyArcs + seq[1:-1]

        genUlusoyRoutes = UlusoyHeuristics.UlusoysIFs_1vehicle(self.info)       
        (sequenceWithIFs, ifLoad, Cost) = genUlusoyRoutes.genSolutionList(onlyArcs)
        return(Cost, ifLoad, sequenceWithIFs, collectFlag)

    def genInitialSolution(self, rule='MaxDepo'):
        '''
        Generate initial solution using a specific predefined rule
        '''
        reqArc = self.info.reqArcList
        collectFlag = {}       
        solutionKeys = ['Load', 'Cost', 'Solution']
        
        for i in reqArc:
            collectFlag[i] = False
            
        unserviced = dictFind.Lookup(collectFlag)
        vehicleNumber = 0
        totalCost = 0
        solutionDict = {}
        
        while unserviced:
            vehicleNumber = vehicleNumber + 1
            (Cost, Load, Sequence, collectFlag) = self.singleRoute(rule, collectFlag)

            look = dictFind.Lookup(collectFlag)
            unserviced = look.get_key(False)
            
            solutionDict[vehicleNumber] = {}.fromkeys(solutionKeys)
            solutionDict[vehicleNumber]['Load'] = Load
            solutionDict[vehicleNumber]['Cost'] = Cost
            totalCost = totalCost + Cost
            solutionDict[vehicleNumber]['Solution'] = Sequence

        solutionDict['Total cost'] = totalCost
        #self.EPSsolution = solutionDict
        return(solutionDict)
    
    def genInitialSolutionIF(self, rule='MaxDepo'):
        '''
        Generate initial solution using a specific predefined rule
        '''
        reqArc = self.info.reqArcList
        collectFlag = {}       
        solutionKeys = ['Load', 'Cost', 'Solution']
        
        for i in reqArc:
            collectFlag[i] = False
            
        unserviced = dictFind.Lookup(collectFlag)
        vehicleNumber = 0
        totalCost = 0
        solutionDict = {}
        
        while unserviced:
            vehicleNumber = vehicleNumber + 1
            (Cost, Load, Sequence, collectFlag) = self.singleRouteIF(rule, collectFlag)
            look = dictFind.Lookup(collectFlag)
            unserviced = look.get_key(False)
            
            solutionDict[vehicleNumber] = {}.fromkeys(solutionKeys)
            solutionDict[vehicleNumber]['Load'] = Load
            solutionDict[vehicleNumber]['Cost'] = Cost
            totalCost = totalCost + Cost
            solutionDict[vehicleNumber]['Solution'] = Sequence
        nRoutes = len(solutionDict.keys())
        solutionDict['Total cost'] = totalCost
        self.EPSsolution = solutionDict
        return(solutionDict, nRoutes)
        
    def genInitialSolutionIFbalanced(self, rule='MaxDepo'):
        '''
        Generate initial solution using a specific predefined rule
        '''
        reqArc = self.info.reqArcList
        collectFlag = {}       
        solutionKeys = ['Load', 'Cost', 'Solution']
        
        for i in reqArc:
            collectFlag[i] = False
            
        unserviced = dictFind.Lookup(collectFlag)
        vehicleNumber = 0
        totalCost = 0
        solutionDict = {}
        
        while unserviced:
            vehicleNumber = vehicleNumber + 1
            (Cost, Load, Sequence, collectFlag) = self.singleRouteIFbalanced(rule, collectFlag)
            look = dictFind.Lookup(collectFlag)
            unserviced = look.get_key(False)
            
            solutionDict[vehicleNumber] = {}.fromkeys(solutionKeys)
            solutionDict[vehicleNumber]['Load'] = Load
            solutionDict[vehicleNumber]['Cost'] = Cost
            totalCost = totalCost + Cost
            solutionDict[vehicleNumber]['Solution'] = Sequence
        nRoutes = len(solutionDict.keys())
        solutionDict['Total cost'] = totalCost
        self.EPSsolution = solutionDict
        return(solutionDict, nRoutes)
            
    def genInitialSolutionIFulosuyHybrid(self, rule='MaxDepo'):
        '''
        Generate initial solution using a specific predefined rule
        '''
        reqArc = self.info.reqArcList
        collectFlag = {}       
        solutionKeys = ['Load', 'Cost', 'Solution']
        
        for i in reqArc:
            collectFlag[i] = False
            
        unserviced = dictFind.Lookup(collectFlag)
        vehicleNumber = 0
        totalCost = 0
        solutionDict = {}
        
        while unserviced:
            vehicleNumber = vehicleNumber + 1
            (Cost, Load, Sequence, collectFlag) = self.singleRouteIFulosoyHybrid(rule, collectFlag)

            look = dictFind.Lookup(collectFlag)
            unserviced = look.get_key(False)
            
            solutionDict[vehicleNumber] = {}.fromkeys(solutionKeys)
            solutionDict[vehicleNumber]['Load'] = Load
            solutionDict[vehicleNumber]['Cost'] = Cost
            totalCost = totalCost + Cost
            solutionDict[vehicleNumber]['Solution'] = Sequence

        nRoutes = len(solutionDict.keys())
        solutionDict['Total cost'] = totalCost
        self.EPSsolution = solutionDict
        return(solutionDict, nRoutes)

    def genInitialSolutionIFulosuyHybridBalanced(self, rule='MaxDepo'):
        '''
        Generate initial solution using a specific predefined rule
        '''
        reqArc = self.info.reqArcList
        collectFlag = {}       
        solutionKeys = ['Load', 'Cost', 'Solution']
        
        for i in reqArc:
            collectFlag[i] = False
            
        unserviced = dictFind.Lookup(collectFlag)
        vehicleNumber = 0
        totalCost = 0
        solutionDict = {}
        
        while unserviced:
            vehicleNumber = vehicleNumber + 1
            (Cost, Load, Sequence, collectFlag) = self.singleRouteIFulosoyHybridBalanced(rule, collectFlag)

            look = dictFind.Lookup(collectFlag)
            unserviced = look.get_key(False)
            
            solutionDict[vehicleNumber] = {}.fromkeys(solutionKeys)
            solutionDict[vehicleNumber]['Load'] = Load
            solutionDict[vehicleNumber]['Cost'] = Cost
            totalCost = totalCost + Cost
            solutionDict[vehicleNumber]['Solution'] = Sequence
        
        nRoutes = len(solutionDict.keys())
        solutionDict['Total cost'] = totalCost
        self.EPSsolution = solutionDict
        return(solutionDict, nRoutes)
    
    def completeInitialSolution(self, EPS_type = 'Real'):
        format = '%*d%*s%*d%*s%*d'
        bestSolutionCost = 1e300000
        bestSolutionNvehicles = 0
        minVehiclesBestSolutionCost = 1e300000
        minVehicles = 1e300000
        if self.printOutput:
            line = ' EPS '
            print(line)
            self.outputLines.append(line)
            line = '------------------------------------------------------'
            print(line)
            self.outputLines.append(line)
            line = ' '
            print(line)
            self.outputLines.append(line)
        i = 0
        rules = ['MaxDepo','MinDepo','MaxYield','MinYield','Hybrid']
        for rule in rules:
            i += 1
            if EPS_type == 'Real': (solutionDict, nRoutes) = self.genInitialSolutionIF(rule)
            elif EPS_type == 'Balanced': (solutionDict, nRoutes) = self.genInitialSolutionIFbalanced(rule)
            elif EPS_type == 'Real_hybrid': (solutionDict, nRoutes) = self.genInitialSolutionIFulosuyHybrid(rule)
            elif EPS_type == 'Balanced_hybrid': (solutionDict, nRoutes) = self.genInitialSolutionIFulosuyHybridBalanced(rule)
            solutionDict = self.trans.newRoute(solutionDict)
            (solutionDict, reduced,  nRoutes) = self.minN.variableReduction(solutionDict)
            if self.printOutput:
                line = format %(5,i+1,8,'Cost :', 7, solutionDict['Total cost'], 15, '# Trips :', 4, nRoutes)
                print(line)
                self.outputLines.append(line)
            if solutionDict['Total cost'] < bestSolutionCost:
                bestSolutionCost = solutionDict['Total cost']
                bestSolution = deepcopy(solutionDict)
                bestSolutionNvehicles = nRoutes
            if (nRoutes <= minVehicles) & (solutionDict['Total cost'] < minVehiclesBestSolutionCost):
                minVehiclesBestSolutionCost = solutionDict['Total cost']
                minVehiclesBestSolution = deepcopy(solutionDict)
                bestSolutionNvehicles = nRoutes
        line = ' '
        print(line)
        self.outputLines.append(line)
        line = '       Best solution : %d' %bestSolutionCost
        print(line)
        self.outputLines.append(line)
        line = '             # Trips : %d' %bestSolutionNvehicles
        print(line)
        self.outputLines.append(line)
        line = ' '
        print(line)
        self.outputLines.append(line)
        line = '  Min trips solution : %d' %minVehiclesBestSolutionCost
        print(line)
        self.outputLines.append(line)
        line = '             # Trips : %d' %bestSolutionNvehicles
        print(line)
        self.outputLines.append(line)
        return((bestSolution,bestSolutionNvehicles),(minVehiclesBestSolution,bestSolutionNvehicles))

    def completeInitialSolutionRandom(self, nSolutions = 200, EPS_type = 'Real', rule = 'RandomRule'):
        format = '%*d%*s%*d%*s%*d'
        bestSolutionCost = 1e300000
        bestSolutionNvehicles = 0
        minVehiclesBestSolutionCost = 1e300000
        minVehicles = 1e300000
        if self.printOutput:
            line = ' EPS %s - Iterations %d' %(rule, nSolutions)
            print(line)
            self.outputLines.append(line)
            line = '------------------------------------------------------'
            print(line)
            self.outputLines.append(line)
            line = ' '
            print(line)
            self.outputLines.append(line)
        for i in range(nSolutions):
            if EPS_type == 'Real': (solutionDict, nRoutes) = self.genInitialSolutionIF(rule)
            elif EPS_type == 'Balanced': (solutionDict, nRoutes) = self.genInitialSolutionIFbalanced(rule)
            elif EPS_type == 'Real_hybrid': (solutionDict, nRoutes) = self.genInitialSolutionIFulosuyHybrid(rule)
            elif EPS_type == 'Balanced_hybrid': (solutionDict, nRoutes) = self.genInitialSolutionIFulosuyHybridBalanced(rule)
            solutionDict = self.trans.newRoute(solutionDict)
            (solutionDict, reduced,  nRoutes) = self.minN.variableReduction(solutionDict)
            if self.printOutput:
                line = format %(5,i+1,8,'Cost :', 7, solutionDict['Total cost'], 15, '# Trips :', 4, nRoutes)
                print(line)
                self.outputLines.append(line)
            if solutionDict['Total cost'] < bestSolutionCost:
                bestSolutionCost = solutionDict['Total cost']
                bestSolution = deepcopy(solutionDict)
                bestSolutionNvehicles = nRoutes
            if (nRoutes <= minVehicles) & (solutionDict['Total cost'] < minVehiclesBestSolutionCost):
                minVehiclesBestSolutionCost = solutionDict['Total cost']
                minVehiclesBestSolution = deepcopy(solutionDict)
                bestSolutionNvehicles = nRoutes
        line = ' '
        print(line)
        self.outputLines.append(line)
        line = '       Best solution : %d' %bestSolutionCost
        print(line)
        self.outputLines.append(line)
        line = '             # Trips : %d' %bestSolutionNvehicles
        print(line)
        self.outputLines.append(line)
        line = ' '
        print(line)
        self.outputLines.append(line)
        line = '  Min trips solution : %d' %minVehiclesBestSolutionCost
        print(line)
        self.outputLines.append(line)
        line = '             # Trips : %d' %bestSolutionNvehicles
        print(line)
        self.outputLines.append(line)
        return((bestSolution,bestSolutionNvehicles),(minVehiclesBestSolution,bestSolutionNvehicles))
          
if __name__ == "__main__":
#    import psyco
#    psyco.full()
    print('start load')
    info = LARP.ReadProblemDataIFs('cen_IF_ProblemInfo/Centurion_a_pickled.dat')
#    info.maxTrip = 43200
    print('loaded')
    y = EPSinitialSolution(info)
    y.completeInitialSolution('Real')
    solutionDict = y.EPSsolution
    e = testSolutions.testSolution(info, solutionDict)
    e.testReportSolutionIFs()
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    